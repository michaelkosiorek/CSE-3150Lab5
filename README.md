Unit test the edep algorithm / other functions with: <br>
```g++ unit_tests_edep.cpp ints_read_matrix.cpp ints_read_vector.cpp expensive_digraph_ep.cpp``` <br>

One of the barbell graphs are manually tested in the unit tests, but I find it necessary to still give an explanation as to what happens in the process of those graphs. 

Suppose you want to get from node 2 to node 5 in the 10-node graph example provided. The first circle is a 4-path +1 rotation, and the second is a 5-path -1 rotation. If you want to get from any node on the left to any node on the right, which is possible, you must first calculate the number of rotations it takes on the right circle to get from that right number to itself. For the number 5 for example, it takes 5 rotations around the circle. You can now use this number to find a zero-cost path from any left-circle node. If you want a zero cost path from 2 to 5, you must find a path such that you get to the right circle's node with a value that equals or is some multiple of the number of rotations required to do a rotation around that circle, so you can evenly negate the number you acquire from the left-circle. So, because you are going to need some multiple of 5, you must find a number ```n``` such that ```4n+2=5k```, where ```k is any positive integer >=0```. ```n``` is the number of rotations around back to the starting number itself, and ```+2``` comes from the fact that you must add +2 to get to the middle portion. A solution to this equation is ```n=2``` where coincidentally ```k=2``` as well. Applying this to the given problem, one can quickly observe this solution works.

You can use this equation to make other equations, such as a -1 path, by simply subtracting -1 from the right side of the equation, or +1 for the +1 paths. This is where one discovers that some paths are not possible, because the equation will simply have no solutions. This was a pretty interesting property to discover.
